<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      version="5.0"
      xml:lang="fr">

  <info>
    <author>
      <personname>
        <firstname>Eugène</firstname>
        <surname>Pamba Capo-Chichi</surname>
      </personname>
    </author>
    
    <title> Description des besoins d'authentification pour DIET V3</title>
    
    <revhistory>
      <revision>
        <revnumber>1</revnumber>
        <date>26/07/2011</date>
        <authorinitials>SysFera</authorinitials>
        <revdescription>
          
        <para> Description des besoins (d'après la première réunion du 26/07/2011).</para></revdescription>
      </revision>
    </revhistory>  
  </info>

  <chapter>
    <title>Documents de référence</title>
      <section>
	 <title>Liste des documents</title>
	<para>
	  <informaltable>
	  <tgroup cols="2">
	  <colspec colwidth="8cm"/>
	  <colspec colwidth="8cm"/>
	  <thead>
	    <row>
	      <entry> ID </entry>
	      <entry>Title</entry>
	    </row>
	  </thead>
	  <tbody>
	    
	    <row>
	      <entry><para>VISHNU_D2_1a-UMS-Design</para></entry>
	      <entry><para xml:id="UMSDesign">VISHNU User Management System Package Design</para></entry>
	    </row>
	    <row>
	      <entry><para>VISHNU_D2_2c-UserManual</para></entry>
	      <entry><para xml:id="UMSUser">VISHNU User Manual</para></entry>
	    </row>
	    <row>
	      <entry><para>VISHNU_D2_2d-GuideAdmin</para></entry>
	      <entry><para xml:id="UMSAdmin">VISHNU - Le guide de l'administrateur</para></entry>
	    </row>
	    <row>
	      <entry><para xml:id="Sogeti">LST-LIP-DIET_Sec</para></entry>
	      <entry><para>DIET ETUDE SECURITE LST - LIP</para></entry>
	    </row>
	    <row>
	      <entry><para xml:id="Dumas07"> DUMAS07 </para></entry>
	      <entry><para> J.-G. Dumas, J.-L. Roch, E. Tannier and S. Varrette. Théorie des Codes : Compression, Cryptage et Correction. 
		Collection Sciences Sup  Dunod publishing, Mars 2007. 
	      </para></entry>
	    </row> 
	    <row>
	      <entry><para xml:id="Securix"> Securix </para></entry>
	      <entry><para> Securix: Documentation sur les PKI et PKIX. Disponible: http://frpki.org/index.php?/intro_PKI.html. </para></entry>
	    </row>
	    
	    
	  </tbody>
	  </tgroup>
	  </informaltable>
	</para>
      </section>
    </chapter>
  <!--<bibliography xml:id="sec.bibliography">
    <title>Documents de référence</title>
    
    <biblioentry xml:id="bib.UMSDesign">
      <abbrev xml:id="bib.UMSDesign.abbrev">VISHNU_D2_1a-UMS-Design</abbrev>
      <title>VISHNU User Management System Package Design</title>
    </biblioentry>
    <biblioentry xml:id="bib.UMSUser">
      <abbrev xml:id="bib.UMSUser.abbrev">VISHNU_D2_2c-UserManual</abbrev>
      <title>VISHNU User Manual</title>
    </biblioentry>
    <biblioentry xml:id="bib.UMSAdmin">
      <abbrev xml:id="bib.UMSAdmin.abbrev">VISHNU_D2_2d-GuideAdmin</abbrev>
      <title>VISHNU - Le guide de l'administrateur</title>
    </biblioentry>
    <biblioentry xml:id="bib.Sogeti">
      <abbrev xml:id="bib.Sogeti.abbrev">LST-LIP-DIET_Sec</abbrev>
      <title>DIET ETUDE SECURITE LST - LIP</title>
    </biblioentry>
  </bibliography>-->

  <chapter>
    <title>Introduction</title>
    <section>
      <title>Présentation</title>
      <para>     
        L'objectif de ce document est de décrire les besoins en terme de sécurité pour la future version 3 de DIET. Plus précisement, nous allons mettre
        l'accent sur trois principaux points:
      </para>
      <itemizedlist>
        <listitem>
          <para> l'authentification des utilisateurs</para>
        </listitem>
        <listitem>
          <para> l'authentification de la hiérarchie DIET</para>
        </listitem>
	<listitem>
          <para> le cryptage des données</para>
        </listitem>
      </itemizedlist>
    </section>
    
    <section>
      <title> Proposition n°1: Utilisation de UMS </title>
    
      <section>
	<title> Authenfication des utilisateurs </title>
	
	<para>
	  <emphasis role = "bold"> Pré-requis:</emphasis> l'environnement de déploiement doit avoir une politique de chiffrement des données circulant via le canal de communication.
	</para>
	<para>
	  L'authentification des utilisateurs va s'inspirer principalement du module <emphasis role = "italic"> UMS (User Managment System) </emphasis>  <link linkend="UMSDesign"> [VISHNU_D2_1a-UMS-Design] </link> développé dans le cadre 
	  du projet VISHNU <footnote><para><link xlink:href="http://www.sysfera.fr/vishnu/"> http://www.sysfera.fr/vishnu/ </link></para> </footnote>. UMS se base sur une authentification unique <emphasis role = "italic"> (Single Sign-On) </emphasis> pour ses 
	  avantages :
	</para>
	<itemizedlist>
	  <listitem>
	    <para> l'utilisateur ne s'authentifie qu'une seule fois via un login et un mot de passe pour accèder à l'infrastructure,</para>
	  </listitem>
	  <listitem>
	    <para> l'authentification est gérée de façon centralisée,</para>
	  </listitem>
	  <listitem>
	    <para> la souplesse de l'utilisation de l'infrastructure (pas d'authentification systématique). </para>
	  </listitem>
	</itemizedlist>
	
	<para>
	  En effet, le nombre conséquent de potentiels protagonistes dans une grille de calculs favorise le mécanisme <emphasis role = "italic"> Single Sign-On </emphasis> pour éviter à l'utilisateur de s'authentifier manuellement à chaque
	  connexion avec un noeud de la grille.
	</para>
	
	
	<section>
	  <title> User Managment System (UMS)</title>
	  <para>
	    
	    Les utilisateurs seront de deux types : utilisateurs ou administrateurs (les administrateurs étant des utilisateurs avec des droits
	    supplémentaires).
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para> Le type (ou groupe) auquel appartient un utilisateur sera défini à sa création par un administrateur.</para>
	    </listitem>
	    <listitem>
	      <para> Un administrateur a la possibilité de définir différents types (ou groupes) d'utilisateurs <emphasis role = "bold">*</emphasis><footnote><para><emphasis role = "italic"> * signifie que cette fonctionnalité ne sera pas disponible dans le coeur de DIET mais dans de futurs développements de modules externes</emphasis></para> </footnote>.
	      </para>
	    </listitem>
	    <listitem>
	      <para> Un administrateur pourra changer dynamiquement le type d'un utilisateur <emphasis role = "bold">*</emphasis>.</para>
	    </listitem>
	    <listitem>
	      <para> Un administrateur aura la possibilité de créer, consulter, modifier ou supprimer les comptes des
	      utilisateurs ou des administrateurs de l'intergiciel. Les fonctions de
	      création et de modification de comptes prendront en paramètre
	      l'information nécessaire. Seuls les
	      administrateurs pourront utiliser ces fonctions.
	      </para>
	    </listitem>
	    <!--<listitem>
		<para> Un administrateur aura la possibilité de créer, consulter, modifier ou supprimer des
		groupes d'utilisateurs de l'intergiciel. Lorsqu'un groupe sera supprimé, tous les utilisateurs du groupe concerné seront également supprimés. 
		Il ne sera pas possible de supprimer le groupe d'administrateurs.
		</para>
		</listitem>-->
	    <!--<listitem>
		<para> Les commandes d'un utilisateur seront stockées. Ce stockage sera borné par une limite définie par le système et une 
		rotation se lancera automatiquement lorsque cette limite sera atteinte (cf commande history sous Linux). 
		</para>
		</listitem>-->
	    <listitem>
	      <para> Un administrateur pourra interdire l'accès à certains services pour un type bien défini d'utilisateurs.
	      </para>
	    </listitem>
	    <listitem>
	      <para> 
		<emphasis role = "bold">Authentification des
		utilisateurs</emphasis> : une fois authentifié dans l'intergiciel, l'utilisateur n'aura plus à s'authentifier
		pour utiliser les services de l'intergiciel avec leurs propres comptes. Cette authentification ouvrira une session 
		rattachée à la machine à partir de laquelle l'utilisateur se sera authentifié. Ce service fermera une session
		soit à la demande de l'utilisateur à qui elle appartiendra, soit parce que
		l'utilisateur aura fermé sa session locale sur la machine à laquelle la
		session de l'intergiciel sera rattachée, soit à cause d'une période sans
		aucun appel aux services de l'intergiciel par l'utilisateur en cause. Ces
		comportements de fermeture de session seront configurables par
		les utilisateurs pour leurs propres comptes. Au lieu d'ouvrir une session,
		cette fonction permettra également aux utilisateurs de se replacer dans
		une de leurs sessions déjà ouvertes. L'utilisation du modèle <emphasis role = "italic"> Single Sign-On </emphasis> nécessite une 
		traçabilité de la session authentifiée. 
	      </para>
	    </listitem>
	    <listitem>
	      <para> Les différents services que fournit notre infrastructure sont rattachées à des machines. Les administrateurs enregistrent les machines et
	      spécifient pour chaque machine le type d'utilisateurs autorisés à y accéder.
	      </para>
	    </listitem>
	    <!--<listitem>
	      <para> 
		Le souci de flexibilité et de généricité de notre infrastructure nécessite que la table qui stocke les informations sur les utilisateurs (donc qui authentifie un utilisateur) 
		soit séparée du reste des tables pour faciliter le passage d'une base de données à un annuaire LDAP etc.
	      </para>
	    </listitem> -->
	  </itemizedlist>
	  
	</section>
	
	<section>
	  <title> Les états d'une authentification</title>
	  <para>
	    <itemizedlist>
	      <listitem>
		<para> <emphasis role = "bold"> Etat initial </emphasis>: un utilisateur préalablement enregistré dans le système d'information de l'intergiciel, non authentifié, n'a accès à aucun
		service.
		</para>
	      </listitem>
	      <listitem>
		<para> <emphasis role = "bold"> Connexion </emphasis>: l'utilisateur sollicite un accès aux services de l'intergiciel en décrivant son identité à l'aide d'un login et d'un mot de passe.
		L'intergiciel contrôle l'identité du demandeur. 
		</para>
	      </listitem>
	      <listitem>
		<para> <emphasis role = "bold"> Etat authentifié </emphasis>: l'identité de l'utilisateur est reconnu par le système. La session authentifiée a une durée de vie liée au mode de connexion choisi 
		par l'utilisateur et pendant cette période, il a accès aux services autorisés au groupe auquel il appartient.
		</para>
	      </listitem>
	      <listitem>
		<para>
		  <emphasis role = "bold"> Déconnexion </emphasis>: Retour à l'état initial.
		</para>
	      </listitem>
	    </itemizedlist>
	    Un cryptage des données circulant à travers le canal de communication pendant les phases précédentes peut ajouter un niveau de sécurité supplémentaire. Cependant, cette partie
	    sera développée dans le module de transport de données.  
	  </para>
	</section>
      </section> 
   </section> <!--Proposition n°1: Utilisation de UMS -->
   
   <section>
      <title> Proposition n°2: Gestion des certificats </title>
      
      <para>
	  <emphasis role = "bold"> Pré-requis:</emphasis> l'autorité de certification doit être dans un environnement sûr.
      </para>
      
      <para>
	Cette deuxième proposition est inspirée du module GSI <footnote><para> Grid Security Infrastructure </para></footnote> de Globus basé sur les mécanismes de PKI <footnote><para> Public Key Infrastructure </para></footnote> <link linkend="Dumas07"> [DUMAS07]</link> avec des
	certificats X509. Le module GSI s'appuie sur une implémentation de la GSS-API<footnote><para> Generic Security Services API </para></footnote>. <!--  supportant le système d'authentification à tierce personne, Kerberos <link linkend="Dumas07"> [DUMAS07]</link>,
	  développé par le Massashusettes Institute of Technology.-->
	Dans ce modèle, chaque utilisateur et chaque service sont identifiés par des certificats.  
	  <section>
	    <title> Les infrastructures à clés publiques (PKI en anglais) </title>
	    <para>
	      Quelles sont les motivations d'un chiffrement à clé publique (chiffrement asymétrique)? 
	    </para>
	    
	    <para>  
	      Pour répondre à cette question, il est important de se demander <link linkend="Dumas07"> [DUMAS07]</link>  : 
	      <itemizedlist>
		<listitem>
		  <para>  
		    Avant d'utiliser un chiffrement à clé secrète (chiffrement symétrique), comment convenir d'une clé?
		  </para>
		</listitem>
		<listitem>
		  <para>  
		    Comment établir une communication sécurisée entre deux entités sans aucun échange préalable de clé?
		  </para>
		</listitem>
	      </itemizedlist> 
	    </para>
	    
	    <para>
	      C'est pour répondre à ces questions qu'en 1976, les bases des systèmes cryptographiques à clé publique ont été introduites par Diffie et Hellman. Le principe
	      de base de ces systèmes est de publier une clé publique pour le chiffrement et seulement le détenteur de la clé privée correspondante est capable
	      de déchiffrer le message. 
	    </para>
	    
	    <para>
	      Ce fonctionnement introduit une nouvelle question:
	      <itemizedlist>
		<listitem>
		  <para>  
		    Comment garantir l'appartenance d'une clé publique à son propriétaire?
		  </para>
		</listitem>
	      </itemizedlist>
	      
	      <para>
		La réponse à cette question définit la notion d'infrastructures à clés publiques dans laquelle un tiers de confiance appelée CA<footnote><para> Certification Authority (autorité de certification en français)</para></footnote> 
		rattache à une clé publique son propriétaire à l'aide d'un certificat numérique. L'idée des PKI est donc de ne pas distribuer des clés mais plutôt des certificats numériques contenant
		ces clés ainsi que l'identité du propriétaire (état civil, adresse, e-mail pour une personne, adresse IP etc).
	      </para>
	      
	    </para>
	    
	    <section>
	    <title> Les fonctions d'une architecture PKI <link linkend="Securix"> [Securix]</link> </title>
	    <para>
	      <itemizedlist>
		<listitem>
		  <para>  
		    <emphasis role = "bold"> Enregistrement : </emphasis> C'est un procédé par lequel le propriétaire qui sera le sujet du certificat se fera connaître auprès d'une AC.
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    <emphasis role = "bold"> Certification : </emphasis> C'est un processus par lequel une autorité de certification (AC) délivre un certificat pour un propriétaire de clé publique et adresse ce certificat au propriétaire ou le publie dans un dépôt de stockage. 
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    <emphasis role = "bold"> Génération de clé : </emphasis> Dans certains cas, le propriétaire peut générer des paires de clés depuis un environnement local et transmettre la requête d'enregistrement vers l'Autorité de Certification. 
		    Dans d'autres cas, les paires de clés peuvent être générées par une AC ou une AE via un générateur de clés. 
		    Le processus de distribution de la clé privée et du certificat vers le propriétaire sera dans ce cas réalisé de manière sécurisée. 
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    <emphasis role = "bold"> Recouvrement de clé : </emphasis> Les clés utilisées pour chiffrer des données, pour le transport ou les échanges peuvent avoir besoin d'être archivées pour satisfaire à des exigences de politique de sécurité. 
		    L'opération d'archivage nécessite par ailleurs une étape de récupération en cas de perte. Le recouvrement est un processus qui autorise la récupération de clés quand une clé est perdue et que des informations précédemment chiffrées ont besoin d'être utilisées. 
		    Les opérations d'archivage et de recouvrement peuvent être réalisées soit par une AC soit par un système de recouvrement de clés séparé de l'AC. 
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    <emphasis role = "bold"> Mise à jour des clé : </emphasis> Toutes les clés doivent pouvoir être remplacées sur une base régulière, quand une clé expire ou qu'elle est compromise. 
		    Si la mise à jour des clés se produit en réponse à une expiration de sa date de péremption, la transition vers la nouvelle clé doit se produire avec facilité, cela exige néanmoins des mécanismes de support de notification de mise à jour. 
		    Dans le cas d'une compromission de clé, le certificat doit être déclaré invalide, et la nouvelle validité du certificat et sa disponibilité doivent être annoncées.  
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    <emphasis role = "bold"> Revocation : </emphasis> Dans la plupart des cas, un certificat reste valide jusqu'à ce que sa période de validité expire. Il y a, cependant, un certain nombre de scénarios qui rendent nécessaire la révocation avant la fin de la période de validité d'un certificat. 
		    Ceux-ci incluent :le propriétaire change de nom, un employé quitte la société qui lui avait délivré le certificat, la clé privée du propriétaire et compromise etc.
		  </para>
		</listitem>
		
	      </itemizedlist>
	    </para>
	  </section>
	  
	    
	<para>
	  Pour revenir à ce qui nous intéresse, la question pratique est d'introduire une infrastructure à clé publique dans DIET.
	</para>
	  </section>
	  
	  <section>
	    <title> Une infrastructures à clé publique pour DIET V3 </title>
	    <para>
	      
	    <section>
	      <title> Politique et definition du scénario de création des certificats </title>
		<para>
		  <itemizedlist>
		    
		    <listitem>
		      <para>  
			Le CA est une machine distincte qui n'est pas connectée à internet. La machine se trouve dans un environnement sécurisée.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Le certificat de l'autorité de certification est disponible par tous les utilisateurs à l'installation de DIET. 
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Chaque futur utilisateur génère un couple clé publique/clé privée et effectue une demande d'ajout dans le système à un administrateur
			en lui envoyant les informations nécessaires à son identification et sa clé publique.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Les administrateurs assurent la création des comptes utilisateurs avec les informations nécessaires pour les identifier et indispensable
			à la génération d'un certificat:  état civil, adresse, e-mail pour une personne etc <emphasis role = "italic"> et éventuellement la clé publique de l'utilisateur</emphasis>.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Chaque utilisateur génère un certificat signé à partir du certificat du CA disponible sur la plateforme.
		      </para>
		    </listitem>
		  </itemizedlist>
		</para>
	    </section>
	    
	    <section>
	      <title> Scénario d'une requête utilisateur via DIET</title>
		<para>
		  <itemizedlist>
		    
		    <listitem>
		      <para>  
			Un utilisateur fait une requête via DIET.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			L'utilisateur chiffre son message via sa clé privée et joint son certificat avec une information mentionnant l'heure de soumission.
		      </para>
		    </listitem>
		    
		     <listitem>
		      <para>  
			L'élement de la hiérarchie DIET qui recoit la requête envoie le certificat au CA pour vérification.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Le CA contrôle le certificat en vérifiant la correspondance entre clé publique et identité de l'utilisateur.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Le CA confirme ou refute le certificat.
		      </para>
		    </listitem>
		    
		    <listitem>
		      <para>  
			Si le certificat est valide, l'élement de la hiérarchie DIET correspondant déchiffre le message via la clé 
			publique de l'utilisateur et chiffre sa réponse via la même clé publique que seul le destinataire, donc détenteur de la clé privée correspondante,
			pourra déchiffrer.
		      </para>
		    </listitem>
		    
		  </itemizedlist>
		</para>
	    </section>
	      <!--<itemizedlist>
		
		<listitem>
		  <para>  
		    Comment gréffer une architecture PKI sur l'architecture de DIET existante?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    Quel acteur génère le couple clé privée/ clé publique? Le propriétaire? ou le CA?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    A quel niveau de notre architecture sera placé l'autorité de certification?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    A quel moment seront signés les certificats?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    Quel type d'annuaire sera utilisé pour stocker les clés publiques?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    Quel scénario d'obtention d'un certificat signé pour un nouvel utilisateur?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    L'annuaire contenant les clés publiques sera partagé par tous les éléments de l'architecture 
		    ou chaque élément stockera les clés publiques de chaque utilisateur via un annuaire perso comme ssh (ce qui complexifiera les mises à jour telle 
		    que la revocation d'un certificat)?
		  </para>
		</listitem>
		
		<listitem>
		  <para>  
		    un daemon DIET servira-t-il de proxy utilisateur avec les autres éléments de la hiérarchie? Ce qui nécessitera que chaque élément de la hiérarchie
		    ne devra connaitre que la clé publique du daemon DIET correspondant mais c'est limite en terme de sécurité car l'obtention de la clé privée
		    de DIET donnera accès à tous les éléments de l'architecture.
		  </para>
		</listitem>
		
	      </itemizedlist>
	      
	    </para> 
	  </section>  
	  
	  <section>
	    <title> Retours de la réunion du 3/07/2011 avec Gael (Mise en place d'une PKI dans DIET) </title>
	    <itemizedlist>
	      
	      <listitem>	  
		<para>
		  Librairie à utiliser pour l'implémentation: OpenSSL (version à préciser)
		</para>
	      </listitem>
	      
	      <listitem>	  
		<para>
		  Le CA est une machine distincte qui n'est pas connecté à internet.
		</para>
	      </listitem>
	      
	      <listitem>	  
		<para>
		  Le certificat de l'autorité de certification est disponible pour tous les utilisateurs à l'installation de DIET. 
		</para>
	      </listitem>
	      
	      <listitem>	  
		<para>
		  L'utilisateur fait une demande au CA avec sa clé publique.
		</para>
	      </listitem>
	      
	      <listitem>	  
		<para>
		  Les utilisateurs envoient une requête à un administrateur qui valide l'identité de l'utilisateur et fait la signature (le CA contrôle l'identité de l'utilisateur et signe le certificat).
		</para>
	      </listitem>
	      
	      <listitem>	  
		<para>
		  Pour la génération de la clé: l'utilisateur crée son couple clé privée/clé publique.
		</para>
	      </listitem>
	      
	    </itemizedlist>
	  </section>
	  -->
	  </para> 
	</section>  
    </para>   
  </section> <!--Proposition n°2: Gestion des certificats -->
    
   <section>
     <title> Authentification de la hiérarchie DIET </title>
     <para>
       Dans la version 3 de DIET, les notions de <emphasis role =
       "italic">master agent</emphasis> et <emphasis role =
       "italic">local agent</emphasis> fusionnent en <emphasis role =
       "italic">agent</emphasis>. Il est donc possible de pointer sur
       n'importe quel noeud de la hiérarchie, ce qui rend plus
       flexible l'infrastructure mais entraîne des besoins en terme de
       sécurité.  Il est donc prévu de concevoir un modèle de sécurité
       utilisant des certificats pour contrôler l'ajout d'éléments à
       une hiérarchie DIET.</para>

     <para>
       Il faut notamment pouvoir se prémunir contre l'ajout d'agents
       ou SeD <emphasis>pirates</emphasis> à une
       hiérarchie déjà existante. L'ajout non contrôlé pourrait
       permettre à une personne mal intentionnée de dévier tout ou
       partie du flux des requêtes et données. Ce type
       d'attaque <emphasis>man-in-the-middle</emphasis> doit être
       empêché. Pour cela, il est nécessaire que chaque élément
       voulant s'ajouter à une hiérarchie soit identifié par un
       certificat lui donnant ou non les droits de connexion. Voir
       l'étude réalisée par Sogeti <link linkend="Sogeti">[LST-LIP-DIET_Sec]</link>.
     </para>

      <!-- <section> -->
      <!--   <title> Modèle d'authentification des machines </title> -->
      <!--   <para> -->
      <!--     Tandis que le module de gestion des utilisateurs contrôle l'identité, les machines définissent les droits d'accès aux services et aux données. -->
      <!--   </para> -->
      <!-- </section> -->

   </section>
   <section>
     <title> Le cryptage des données </title>
     <para>
       L'utilisation d'un modèle avec une authentification unique manipule un jeton. Le problème de cette technique est que l'interception du jeton permet une intrusion dans l'infrastructure et l'accès aux services de l'intergiciel. C'est pour 
       cette raison qu'il est judicieux de limiter la durée de vie d'un jeton. Pour aller plus loin et rajouter un niveau de sécurité supplémentaire, il est possible de rendre le jeton inutilisable s'il est intercepté
       en cryptant les données circulant via le canal de communication. </para>
   </section>
 </chapter>  
  
</book>
